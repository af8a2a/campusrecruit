## 实习
做什么工作  
实习工作主要是参与公司自研渲染引擎的开发。我的主要工作是给引擎的场景导功能提供了FBX格式的支持,还有一个就是添加HDR贴图的适配让IBL的渲染可以读取HDR贴圈的数据。再就是使用Renderdoc去定位的shader错误。  

mipmap生成怎么做:  

宽,高,深度除2,开辟新的Image类将原来数据用2×2卷积和求均值复制到新mipmap图片中。

HDR贴图的加载流程
主要是opengL接口中格式从无符号字节改为32位浮点数  

导出格式怎么做  
使用ASSIMP库，引擎将八叉树中的数据导出为obj字符串的功能，将字符用ASSIMP解析得到FBX和其他格式场景或模型  
 
接口怎么做  
引擎通过将函数接口生成AngelScript API给UI逻辑脚本使用，按照原有API接口添加新定义  

怎么测试性能的
VS2022的性能测试
在Release下进行测试，根据火焰图，函数耗时，关键代码段耗时等方法确定瓶颈

优化策略
原有的接口如果场景元素过多，瓶颈在可绘制元素转字符串这一阶段，使用lambda表达式将drawable对象数组的每个元素进行处理生成子场景，再将子场景合并  

OpenMP怎么做的并行化
将导出场景划分为多个子任务，然后使用#pragma omp parrell for为for循环并行化，在输出部分使用#pragma omp parrell atomic 声明临界区资源

改了哪些shader  
修改了IBL部分读取环境光贴图的textureLOD,原有的实现是直接读取DDS中的环境光数据，OpenGL的RHI实现中没有做mipmap的适应，而且光照数据信息是LDR的，在PBR流程中失真。我实现了Mipmap后，使用TextureLOD根据roughness粗糙度数进行LOD，再通过tonemapping色调映射回LDR显示。

OpenGL RHI改了什么
为RHI添加HDR贴图的适配，具体的说就是读取GL_FLOAT浮点数据的材质生成CubeMap供TextureLOD使用

为什么PBR要用HDR贴图
hdr格式，是因为LDR格式的范围在[0.0,1.0]之间，而HDR格式允许超过1.0这个极限，可以保留更多的细节，而且它的光源信息更加符合真实的光源强度，可以得到正确的结果。

为什么PBR需要低分辨率的立方体贴图
具有粗糙表面的表面上对预过滤贴图采样，也就等同于在较低的 mip 级别上对预过滤贴图采样。越粗糙，反射越分散，越光滑，反射越集中。因此我们需要用mipmap来表示不同roughness。mipmap等级高的图像会更模糊，而粗糙度越高，表面越不光滑，光线会更多地散射，产生较为模糊的反射。


实习收获
提高沟通能力和协作能力，接触实际的开发流程.分任务,写代码，提交，ld负责review合并
  
  

## 图形学部分  

### 光照模型



| Bling-phong            | Phong                      |
| ---------------------- | -------------------------- |
| 半程向量计算高光       | 法线计算高光               |
|          镜面光更加锐利              | 反光度小时出现高光断层                           |
| 法线与半程向量约束点乘 | 反射向量与观察向量约束点乘 |
**Phong光照模型**将光照分为三部分：环境光(Ambient)、漫反射光(Diffuse)和镜面(Specular)光照。环境光即来自其它物体，而非直接光源的光照。在Phong模型中是一个常数。漫反射即粗糙物体表面均匀的反射光线到各个方向所产生的光照效果。镜面光照也称高光反射，由光滑物体表面平行地向一个方向反射出来的光照效果。**Phong光照模型**中，视线向量和反射向量的角度不允许大于90度。如果大于90度的话，点乘的结果就会是负数，镜面的贡献成分就会变成0。
**Blinn-Phong**镜面反射的计算引入了半程向量（halfway vector）向量，半程向量是视线方向和反射向量之间的夹角。通过测量法线和半程向量之间的角度计算镜面反射。

```glsl
if(blinn) { 
vec3 halfwayDir = normalize(lightDir + viewDir); 
spec = pow(max(dot(normal, halfwayDir), 0.0), 16.0); 
} 
else
{ 
vec3 reflectDir = reflect(-lightDir, normal);
spec = pow(max(dot(viewDir, reflectDir), 0.0), 8.0);
}
```


### 渲染管线  

一堆原始图形数据经过各种变化处理最终出现在屏幕的过程

![渲染管线](https://pic4.zhimg.com/80/v2-51a797a04016de8c226649c168d3cf9b_720w.webp )

#### **应用程序阶段**  

应用阶段在CPU上执行，这里的操作会影响到后续执行阶段的性能，应用阶段的算法和设置直接影响到后续渲染的三角形数量 。应用阶段也可能通过compute shader在GPU上执行。

  

应用阶段内部没有子管线 ，为了提高性能，通常应用阶段是多核CPU上并行执行，应用阶段最通常的功能是碰撞检测，应用阶段也是也是处理键盘，鼠标或头戴显示设备等输入设备的地方。


最终，应用阶段将把几何片元，如点，线，三角形输出给几何处理阶段。  

#### **几何处理阶段**  

![几何处理阶段](https://pic3.zhimg.com/80/v2-69a9c0ac6027337690b18d871b050fbe_720w.webp )
本阶段主要2个任务：顶点位置计算和程序员控制顶点输出数据，比如法线 和纹理坐标。此本阶段中，模型坐标从模型空间转换到世界空间，然后转换到相机空间，再通过正交投影或透视投影转换到齐次坐标空间中，z坐标不会储存在图像中。最终模型的z坐标将被储存在zbuffer中。



(可选) Vertex Processing


在Vertex Shading后，根据GPU支持的不同，还可以会有如下的处理阶段：tessellation, geometry shading和stream output

tessellation(曲面细分着色器): 根据物体距离像机的远近自动生成曲线表面。

geometry shading(几何着色器): 用于自动生成新的顶点，能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点
```glsl
#version 330 core
layout (points) in;
layout (line_strip, max_vertices = 2) out;

void main() {    
    gl_Position = gl_in[0].gl_Position + vec4(-0.1, 0.0, 0.0, 0.0); 
    EmitVertex();

    gl_Position = gl_in[0].gl_Position + vec4( 0.1, 0.0, 0.0, 0.0);
    EmitVertex();

    EndPrimitive();
}
```

stream output: 将数据通过数组发送给基础处理单元，这些数据可以被CPU,或GPU在之后的阶段使用，通过用于粒子发射器。  

Clipping

视锥体范围为（-1，-1，-1）到（1，1，1），本阶段将裁剪掉在视锥体之外的三角形。  

![几何处理阶段](https://pic2.zhimg.com/80/v2-5b3310b5c8569c3d51583fbad6e41969_720w.webp )

Screen Mapping

在此阶段，三角形将坐标转换到屏幕空间中

![几何处理阶段](https://pic4.zhimg.com/v2-a836bb277f7ec8b3936333ad68d0837b_r.jpg)

#### **光栅化**

![几何处理阶段](https://pic3.zhimg.com/80/v2-39ae422dcc222bbc0fdd8668b335e352_720w.webp)
**光栅化阶段**把图元映射为最终屏幕上显示的颜色。包括**光栅化**，**片段着色，深度测试和混合。光栅化将**顶点转为屏幕上的像素。**片段着色器**计算每个像素的最终颜色。**深度测试**通过深度信息判断像素的**遮挡关系。混合阶段**通过**透明度**将像素进行混合。

triangle setup: 此阶段用于生成边，计算微分，和其它三角形相关数据，还有几何阶段数据的插值计算等，固定功能硬件用来执行这些任务。  

triangle traversal: 将三角形转换成像素。  

#### **像素处理**  

Pixel Shading: 通常在shader中程序员提供算法进行计算，最重要的是进行纹理着色，比如输入纹理最终输出每个像素颜色.  

Merging  

所有像素都储存在color buffer中，z值储存在z-buffer中。stencil buffer用来记录几何片元的位置，通常每像素包含8位，他控制几何体最终被放在color buffer和z-buffer，通常用来算作特殊效果。


framebuffer通常由系统上的所有缓冲区组成。

最终color buffer显示在屏幕上，通常使用双缓冲实现。

#### 省流：
**应用阶段**：
视锥剔除（culling，背剔除，BVH...）-》查询图元生成渲染数据（VAO设置数据访问规则和绑定shader，VBO存放数据）-》设置shader参数-》drawcall
**几何阶段**：
1. 顶点处理：MVP矩阵-》计算顶点位置并转化为NDC下的坐标-》包括顶点，法线，纹理坐标
2. 顶点着色
3. Geometry Shader -》自定义图元形状
4. 锥体裁剪（剔除屏幕外的像素）和屏幕映射
**光栅化**
1. 三角形设置（图元装配）：计算三角形的数据（方程与深度值）
2. 三角形遍历：判断像素是否在三角形内
3. 插值，stencil测试，alpha测试，深度测试 -》 depthbuffer
**像素处理** ： 光照与阴影的计算

### 延迟渲染
(参考[延迟渲染 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/102134614))

| 前向渲染         | 延迟渲染         |
| ---------------- | ---------------- |
| 使用片段相关信息 | 使用Gbuffer数据  |
|          O(nm)        |O(n+m)                  |
| 光照计算每个像素 | 计算看得见的像素 |

为什么需要延迟渲染
前向渲染对很多看不到的光源进行光照着色，有性能浪费
前向渲染枚举每一个片元，在对所有光照信息进行累加光照计算，时间复杂度为O(nm),代价大
延迟渲染先渲染场景一次获取对象的各种几何信息，并储存在G缓冲中(MRT),各种信息保存在对应贴图信息中
![](https://learnopengl-cn.github.io/img/05/08/deferred_overview.png)
省流：延迟渲染从第一次pass获取了屏幕空间下的光照信息，在第二次pass中对已经经过深度测试后屏幕空间下的片元进行光照计算
缺陷：
延迟渲染基于后处理，自然不能使用基于硬件的AA抗锯齿(MSAA等)，UE4启用延迟渲染后只支持FXAA跟TXAA。
不支持透明物体的渲染：渲染透明物体的逻辑是对每个图元做深度测试，mix混合，但是渲染到texture只能记录一个像素。妥协方案是先渲染非透明的Mesh，后续再单独渲染透明Mesh。
带宽占用大：在1920 * 1080 * 4（RGBA）* 4（MRT）* 8（Byte to bit） * 60（FPS），占用的带宽15G
只能使用同一个光照pass：使用屏幕空间下的结果进行渲染，自然不能得到像素归属哪一个mesh，使用哪一个shader
### View矩阵 
position， lookat， up  三要素
position:从哪里看  

lookat:看哪里  

up:摄像机的高度轴  

  

正交投影：平移缩放  
透视投影：fov，aspect，Fnear，Ffar  


### 欧拉角
俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)
优点：直观，易插值 缺点：1. 万向节死锁（y轴（pitch）90度时，x和z轴旋转不再有区别） 2. 旋转有次序要求
矩阵
优点：方便计算 缺点：不适合插值且需要存储空间较大
四元数 解决万向节死锁
缺点：不直观

Mipmap  

LOD
纹理，模型等对象的简单版本，比如图片分辨率，网格面数

点是否在三角形内的判断  

1.重心坐标计算 uA+vB+wC-> 0<=u,v,w<=1  

2.发出射线计算交点数  

3.三角形的三个边向量AB、BC、CA与点P到三个边的方向向量的叉积

  
  

三角形-三角形相交测试(RTR4)  

![](https://pic4.zhimg.com/80/v2-76218534baf94a7f1bbdef79224be2bb_720w.webp)

  

**Guigue**  
将三角形投影到某个平面上，然后在该平面上判断两个二维三角形是否相交  

法线贴图  
纹理存储法线数据  


切线空间  
相对于世界空间，由TBN基底表示  
切线（Tangent）：与纹理坐标的U轴方向对齐，指示表面上的水平变化方向。  
副切线（Bitangent或Binormal）：与纹理坐标的V轴方向对齐，指示表面上的垂直变化方向。  
法线（Normal）：垂直于表面的单位向量，用于光照计算等操作。  

  

屏幕空间的相关算法  

SSAO(屏幕空间环境光遮蔽)  
屏幕空间中对全局光照的近似。SSAO 的核心是假设间接光照恒定，景物表面都是漫反射材质，于可以通过估计着色点的可见性，直接地计算出间接光照效果。

SSR(屏幕空间光线追踪)  

SSDO（Screen Space Directional Occlusion）
假设间接光照来自附近，如果着色点和相机之间被某个物体遮挡了，那么这个遮挡物便会作为次级光源向着色点贡献间接光照，而直接光照则从那些未被遮挡的方向射入着色点。

  

Bezier曲线  

数据点:起点，终点  
控制点:令曲线弯曲，但未必经过  

面剔除
根据顶点环绕顺序确定正面，背面
  

gamma矫正  
肉眼亮度与CRT显示指数不匹配  
校正后一般偏亮:pow(color,vec3(2.2));

动态环境映射
设置六个方向的摄像机渲染到纹理，再对表面贴图

逐vertex光照和逐fragment光照的区别。  
顶点计算的光照计算量小，但是插值不平滑，光照效果差  
片段计算的光照计算量大，但是插值结果较好，得到的效果更好

深度测试
Early-Z:光栅化和片元阶段中间进行深度测试

  
天空盒  
深度z=w

OpenGL默认顶点属性布局
123123123(交错)
111222333分批(Batched)
```c++
float positions[] = { ... };
float normals[] = { ... };
float tex[] = { ... };
// 填充缓冲
glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), &positions);
glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &normals);
glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &tex);
```


### 光线追踪

```

for (P in pixels )

      for (T in triangles )

            determine if ray through P hits T

```
#### 光线追踪和光栅化的区别

光线追踪是基于光线和物体交互的结果返回颜色,光栅化将渲染对象转为屏幕上的像素呈现图形。　　
光线追踪模拟光线的传播，反射等行为，渲染的效果如全局光照，阴影质量高。光栅化需要通过贴图，多pass的计算来实现。  
光线追踪的计算量大，场景复杂时需要时间提升较多，光栅化会预先计算哪些像素需要舍弃，渲染速度快。
光栅化使用三角形几何网格表示渲染对象，光线追踪以几何体方式描述物体

#### 光线追踪模型  
Whitted光线追踪  
PathTracing路径追踪  

总体上来说，就是每个像素点发出多条光线，每条光线会通过之前构建的包围盒找到与场景中物体的第一个交点，然后根据渲染方程计算该交点的颜色，并返回，最后将全部发射的光线的颜色求平均，就得到该像素的颜色。

#### 降噪
滤波，消除高频噪声
MSAA思路,提高SPP(sample per pixel)
TAA的思路(根据上一帧的结果计算像素移动)
重要性采样


#### 加速结构
BVH(包围盒层次结构)
根据包围盒快速求交，加速光线相交计算
```
Intersect(Ray ray, BVH node) { 
	if (ray misses node.bbox) return;
	if (node is a leaf node) 
		test intersection with all objs; 
		return closest intersection; 
	hit1 = Intersect(ray, node.child1); 
	hit2 = Intersect(ray, node.child2); 
return the closer of hit1, hit2; 
}
```
### 点乘叉乘  

点乘的结果是两个向量的数量积，表示了两个向量之间的相似程度  

点乘的值与向量的模长和夹角余弦有关  

  

叉乘的结果是一个新的向量，这个向量与原来的两个向量都垂直，并且其方向满足右手法则。  

叉乘的模长表示了两个原始向量所张成的平行四边形的面积。  

### 透明效果怎么做  
mix混合


解决半透明物体渲染：  
先绘制所有不透明的物体。  
对所有透明的物体排序。  
按顺序绘制所有透明的物体。  

### 为什么使用4x4矩阵不使用3x3
需要第四个坐标w表示透视，实现近大远小
translate矩阵平移项在第四列，3x3无法表示平移
3x3矩阵无法表示投影矩阵

### 透视除法
投影矩阵变换到裁剪空间后进行透视除法

### 正交投影矩阵
![](https://learnopengl-cn.github.io/img/01/08/orthographic_frustum.png)
由宽、高、近(Near)平面和远(Far)平面所指定,直接将平截头体内部的所有坐标映射为标准化设备坐标,不进行透视除法



### z-fighting

### PBR
1. 基于微平面(Microfacet)的表面模型。
2. 能量守恒。
3. 应用基于物理的BRDF。

PBR相比传统渲染有什么区别：基于物理，辐射度量学，材质表征更为细腻和真实，传统的模型只是一个特化和近似  

PBR需要贴图中包含哪些内容 abeldo，法线，粗糙度，金属度，自发光等 

微表面
roughness 粗糙度，描述微平面中，朝向方向沿着某个向量ℎ(半程向量)方向的比例
![](https://learnopengl-cn.github.io/img/07/01/ndf.png)

能量守恒
```glsl
float kS = calculateSpecularComponent(...); // 反射/镜面 部分
float kD = 1.0 - ks;                        // 折射/漫反射 部分
```

渲染方程
$$
L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$

#### BRDF
radiance/irradiance比值  
##### Cook-Torrance BRDF

$$
f_r = k_d f_{lambert} +  k_s f_{cook-torrance}
$$
$$f_{lambert} = \frac{c}{\pi}$$
$$f_{cook-torrance} = \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}$$
结果:
$$L_o(p,\omega_o) = \int\limits_{\Omega} (k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})L_i(p,\omega_i) n \cdot \omega_i  d\omega_i$$

**D**  aka NDF
表示反射光强度在法线附件的分布，微平面向量和面法向越接近，强度越大。通过粗糙度改变lobe形状
e.g. 如果我们的微平面中有35%与向量取向一致，则法线分布函数或者说NDF将会返回0.35
```glsl
float DistributionGGX(vec3 N, vec3 H, float roughness)
{

   // TODO: To calculate GGX NDF here
    float a = roughness*roughness;

    float a2 = a*a;

    float NdotH = max(dot(N, H), 0.0);

    float NdotH2 = NdotH*NdotH;

  

    float nom   = a2;

    float denom = (NdotH2 * (a2 - 1.0) + 1.0);

    denom = PI * denom * denom;

    return nom / max(denom, 0.0001);

}
```
  

**F**  

表示菲涅尔效应，掠视金属时反射较多的光而俯视时反射光较少
```glsl
vec3 fresnelSchlick(vec3 F0, vec3 V, vec3 H)
{
    // TODO: To calculate Schlick F here
    return F0 + (1.0 - F0) * pow(clamp(1.0 - max(dot(H, V), 0.0), 0.0, 1.0), 5.0);
}
```



G
微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量。几何函数是一个值域为[0.0, 1.0]的乘数，其中白色或者说1.0表示没有微平面阴影，而黑色或者说0.0则表示微平面彻底被遮蔽。
![](https://learnopengl-cn.github.io/img/07/01/geometry.png)
```glsl
float GeometrySchlickGGX(float NdotV, float roughness)
{
    // TODO: To calculate Smith G1 here
    float a = roughness+1.0;
    float k = (a * a) / 8.0;
    float nom = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return nom / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    // TODO: To calculate Smith G here
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = GeometrySchlickGGX(NdotV, roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}
```

**IBL**  

从周围的环境中获取光源信息，通常使用hdr格式的cubemap，将cubemap的每个pixel看作光源，在渲染方程中使用，将环境光这一部分考虑进去后使得物体看起来更加正确。


**环境光**  

天空盒产生的光照，由diffuse和specular两部分组成的，将cubemap的每个pixel视为一个光源。使用一个方向向量 wi 对此立方体贴图进行采样，我们就可以获取该方向上的光照强度。

重要性采样  




#### Kulla-Conty BRDF
引入一个微表面 BRDF 的补偿项，来补偿光线的多次弹射，使得材质的渲染结果可以近似保持能量守恒
$$
f_r = f_{micro} +  f_{add}*f_{ms}
$$
$$
f_{add}=\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}
$$
$$
f_{ms}=\frac{(1-E_{μ_O})(1-E_{μ_i})}{\pi(1-E_{avg})}
$$
$$
	F_{avg}=2\int_{0}^{1} F(μ)μ dμ
$$
fms的形式
fms仅关注积分结果为1-E(μ),计算不是重点

为什么损失能量
G项只考虑了光线一次弹射，没考虑多次弹射,表面粗糙度的增大，物体表面反射的总能量越来越少，这导致渲染出来的物体表面越来越暗
![](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.45/blog/PBRM/11.jpg)
E(μ)=BRDF一次弹射输出的总能量
### shader
#### shader是什么，一般控制什么数据
Shader是着色器，一般分为vertex shader和fragment shader，是一段能够针对3D对象进行操作、并被GPU所执行的程序。通过对这些程序进行编程，程序员就能够获得绝大部分想要的3D图形效果。

uniform和varying  

uniform变量是从CPU到GPU的单向数据传输,存储与模型、视图和投影矩阵等相关的常量  

varying变量是从顶点着色器传递到片元着色器的数据

```glsl
layout (std140) 
uniform Matrices { 
	mat4 projection; 
	mat4 view;
}; //UBO
uniform mat4 model;
```

UBO：和普通的uniform变量相比，就像是一个结构体，可以容纳更多变量，存储在显存的常量区，速度较快，编译时大小是确定的，而且大小是有限制的，在着色器里可读但不可写，修饰符uniform，一般用于少量的变量设置，在所有着色器都常用到。Uniform缓冲对象可以优化着色器的性能。因为它们将多个uniform变量组合成单个缓冲对象，这减少了CPU与GPU之间的通信次数，从而提高了效率。

## by LearnOpenGL
一次设置很多uniform会比一个一个设置多个uniform要快很多。
第二，比起在多个着色器中修改同样的uniform，在Uniform缓冲中修改一次会更容易一些。
如果使用Uniform缓冲对象的话，你可以在着色器中使用更多的uniform。

所有shader共享相同的uniform数据，前提条件是两个着色器都定义了相同的Uniform数据结构块

CPU/GPU if  

CPU上的分支语句是直接根据条件来选择执行的代码路径，一次只执行一个分支  

GPU上的分支语句则采用的是流SIMD,GPU中的多个线程同时执行相同的指令，但每个线程可能有不同的分支条件,所有线程都计算所有分支路径，但只选择符合各自分支条件的结果  

法线贴图
保存法线信息的贴图，储存法线向量

法线贴图为什么是蓝色的  

常见的法线贴图中任意一点的颜色通道的b（rgb的b）值都大于0.5，偏蓝色的法线纹理存储了在每个顶点各自的切线空间，如果一个顶点的法线方向不变，那么在它的Tangent Space中，新的normal值就是z轴方向，也就是说值为(0, 0, 1)。向量每个维度的取值范围在(-1, 1)，而纹理每个通道的值范围在(0, 1)，因此我们需要做线性变换映射到[0,1]，即pixel = (normal + 1) / 2.法线值(0, 0, 1)实际上对应了法线纹理中RGB的值为(0.5, 0.5, 1)，而这个颜色也就是法线纹理中那大片的蓝色

视差贴图
根据储存在纹理中的几何信息对顶点进行位移或偏移

HDR
OETF：光转电传递函数（opto-electronic transfer function）
把场景线性光（relative scene linear light）转换到非线性视频信号值,例如，当我们用摄像机拍摄时，现实场景的光会经过一次OETF转换成摄像机的视频信号
EOTF：电转光传递函数（electro-optical transfer function），负责把非线性视频信号值（non-linear signal value）转换成显示光亮度（display light）。例如，当我们把一个视频信号显示到屏幕上时，会经过一次EOTF

色调映射(Tone Mapping)
将浮点颜色值转换到LDR
Reinhard算法,保留更多亮处细节，暗处细节损失较多
```glsl
void main()
{             
    const float gamma = 2.2;
    vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;

    // Reinhard色调映射
    vec3 mapped = hdrColor / (hdrColor + vec3(1.0));
    // Gamma校正
    mapped = pow(mapped, vec3(1.0 / gamma));

    color = vec4(mapped, 1.0);
}   
```
曝光
```glsl
uniform float exposure;

void main()
{             
    const float gamma = 2.2;
    vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;

    // 曝光色调映射
    vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);
    // Gamma校正 
    mapped = pow(mapped, vec3(1.0 / gamma));

    color = vec4(mapped, 1.0);
}  
```
![](https://learnopengl-cn.github.io/img/05/06/hdr_exposure.png)

**泛光**
光源附近的光芒，产生光晕
![](https://learnopengl-cn.github.io/img/05/07/bloom_example.png)

光晕模糊效果怎么做
高斯模糊滤波
```glsl
#version 330 core
out vec4 FragColor;
in vec2 TexCoords;

uniform sampler2D image;

uniform bool horizontal;

uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

void main()
{             
    vec2 tex_offset = 1.0 / textureSize(image, 0); // gets size of single texel
    vec3 result = texture(image, TexCoords).rgb * weight[0]; // current fragment's contribution
    if(horizontal)
    {
        for(int i = 1; i < 5; ++i)
        {
            result += texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i];
            result += texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i];
        }
    }
    else
    {
        for(int i = 1; i < 5; ++i)
        {
            result += texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i];
            result += texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i];
        }
    }
    FragColor = vec4(result, 1.0);
}
```
高斯模糊原理
用水平权重在整个纹理上进行水平模糊，然后在经改变的纹理上进行垂直模糊
![](https://learnopengl-cn.github.io/img/05/07/bloom_gaussian_two_pass.png)

#### 纹理
##### 纹理环绕方式
|环绕方式|描述|
|---|---|
|GL_REPEAT|对纹理的默认行为。重复纹理图像。|
|GL_MIRRORED_REPEAT|和GL_REPEAT一样，但每次重复图片是镜像放置的。|
|GL_CLAMP_TO_EDGE|纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。|
|GL_CLAMP_TO_BORDER|超出的坐标为用户指定的边缘颜色。|
![](https://learnopengl-cn.github.io/img/01/06/texture_wrapping.png)
##### OpenGL设置纹理
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
##### 纹理过滤(Texture Filtering)
GL_NEAREST
GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：
![](https://learnopengl-cn.github.io/img/01/06/filter_nearest.png)
GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：

![](https://learnopengl-cn.github.io/img/01/06/filter_linear.png)
效果
![](https://learnopengl-cn.github.io/img/01/06/texture_filtering.png)
### Z缓冲(Z-buffer)
OpenGL存储它的所有深度信息于一个Z缓冲(Z-buffer)中，也被称为深度缓冲(Depth Buffer)，深度值存储在每个片段里面（作为片段的**z**值）。当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)

### 摩尔纹与Mipmap
![](https://pic3.zhimg.com/80/v2-250a678089fc5870d0b540d0e09ccad2_720w.webp)
图片缩小后产生摩尔纹现象，是采样频率跟不上信息频率的结果，即屏幕像素数量低于纹素数量,图片离我们很远时，1个像素几乎包含了12个纹素
当这种1个屏幕像素包含非常多的纹素时，像素如何去对这些纹素进行采样处理，那就由不了我们了。如下图所示，在像素纹素一对多及其严重的区域，像素直接将所包含的纹素全部平均化了。
![](https://pic1.zhimg.com/80/v2-67537b5083a377aab2b06931a3902724_720w.webp)

解决因采样频率差异而导致的摩尔纹问题,需要mipmap，使得采样频率能尽可能与纹素频率接近
既然屏幕像素在对远处纹理进行采样时，都陷入如何对包含的大量纹素进行合理处理时，那不如让屏幕像素在采集远处纹理时，也能像采集近处纹理一样，一个像素对应一个纹素。这样既能保留我们所指定的信息，又能减少各种纹理过滤插值的计算。**多级渐远纹理 Mipmap** 就是用来实现一个像素采样尽可能少的纹素。
![](https://pic1.zhimg.com/80/v2-40618a0aa446954cdbd57f02f3be61e8_720w.webp)
为不同距离准备不同分辨率的纹理。纹理离视口越远，则mipmap取的层级就越高，mipmap层级越高，纹素就越少，这也就实现了纹素随距离变化，避免了采样频率和纹素频率差别过大的情况出现。
为一张纹理生成mipmap，会增加1/3的显存，但是减轻走样的同时也减少了计算量。
![](https://pic1.zhimg.com/80/v2-284cf9f7a3a29d6f8b9812882e6311b0_720w.webp)
### 阴影贴图
先从光源视角渲染一次获得深度阴影贴图
在从摄像机渲染一次，根据阴影贴图的深度和当前像素的深度对比是否应该生成阴影效果
``` glsl
float depth = (worldPos - LightPos).length;

float depthShadowMap = tex2D(ShadowMap, UVShadow);

if(depth > depthShadowMap)

{

return float4(0,0,0,1);

}

else

{

return tex2D(Texture, uv);

}
```
PCF
采样取均值，PCF的滤波半径决定了阴影边缘的柔和程度，一般来说滤波半径越大则柔和，相反阴影边缘越锐利
```glsl
float PCF(sampler2D shadowMap, vec4 coords) {
    //implement the PCF of shadow map
    float shadow=0.0;

    float cur_depth=coords.z;

    float filterSize=  1.0 / 2048.0 * 10.0;

    poissonDiskSamples(coords.xy);

    for(int i=0;i<NUM_SAMPLES;i++){

        vec2 textureCoord=poissonDisk[i]*filterSize+coords.xy;

        float closestDepth=unpack(vec4(texture2D(shadowMap,textureCoord).xyz,1.0));

        if(closestDepth>cur_depth-BIAS){

            shadow+=1.0;

        }

    }
    return shadow/float(NUM_SAMPLES);
}
```
PCSS
由PCF启发，软阴影的边缘用更大的滤波半径进行滤波，而对于那些不需要太过柔和阴影边缘的地方，则采用更小的滤波半径

![](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.41/blog/PCSS/9.jpg)
```glsl
float findBlocker( sampler2D shadowMap,  vec2 uv, float zReceiver ) {  
  const int radius = 40;  
  const vec2 texelSize = vec2(1.0/2048.0, 1.0/2048.0);  
  float cnt = 0.0, blockerDepth = 0.0;  
  int flag = 0;  
  for(int ns = 0;ns < BLOCKER_SEARCH_NUM_SAMPLES;++ns)  
  {  
      vec2 sampleCoord = (vec2(radius) * poissonDisk[ns]) * texelSize + uv;  
      float cloestDepth = unpack(texture2D(shadowMap, sampleCoord));  
      if(zReceiver - 0.002 > cloestDepth)  
      {  
        blockerDepth += cloestDepth;  
        cnt += 1.0;  
        flag = 1;  
      }  
  }  
  if(flag == 1)  
  {  
	  return blockerDepth / cnt;  
  }  
  return 1.0;  
}  
  
float PCF(sampler2D shadowMap, vec4 shadowCoord, float radius) {  
  const vec2 texelSize = vec2(1.0/2048.0, 1.0/2048.0);  
  float visibility = 0.0, cnt = 0.0;  
  for(int ns = 0;ns < PCF_NUM_SAMPLES;++ns)  
  {  
    vec2 sampleCoord = (vec2(radius) * poissonDisk[ns]) * texelSize + shadowCoord.xy;  
    float cloestDepth = unpack(texture2D(shadowMap, sampleCoord));  
    visibility += ((shadowCoord.z - 0.001) > cloestDepth ? 0.0 : 1.0);  
    cnt += 1.0;  
  }  
  return visibility/cnt;  
}  
  
float PCSS(sampler2D shadowMap, vec4 shadowCoord){  
  
  // STEP 1: avgblocker depth  
  float avgBlockerDepth = findBlocker(shadowMap, shadowCoord.xy, shadowCoord.z);  
  
  // STEP 2: penumbra size  
  const float lightWidth = 50.0;  
  float penumbraSize = max(shadowCoord.z-avgBlockerDepth,0.0)/avgBlockerDepth*lightWidth;  
  
  // STEP 3: filtering  
  return PCF(shadowMap, shadowCoord, penumbraSize);  
  //return 1.0;  
  
}
```

SSR(屏幕空间光线追踪)
模拟光线从给定一个起点沿着某个方向每次步进一定的距离，用步进后光线的深度对比光线所在的屏幕坐标的场景物体深度，若光线深度大于场景物体深度，则相交
步长
步长取大了，效果会变差，因为求出来的交点会在物体后面，步长越大误差越大，反射出来的画面会有“断层”的瑕疵，而步长取短了会影响性能


```glsl
void main() {

  float s = InitRand(gl_FragCoord.xy);

  

  vec3 L = vec3(0.0);

  // L = GetGBufferDiffuse(GetScreenCoordinate(vPosWorld.xyz));

  

  vec3 worldPos = vPosWorld.xyz;

  vec2 screenUV = GetScreenCoordinate(vPosWorld.xyz);

  vec3 wi = normalize(uLightDir);

  vec3 wo = normalize(uCameraPos - worldPos);

  

  // 直接光照

  L = EvalDiffuse(wi, wo, screenUV) * EvalDirectionalLight(screenUV);

  

  // Screen Space Ray Tracing 的反射测试

  // L = (GetGBufferDiffuse(screenUV) + EvalReflect(wi, wo, screenUV))/2.;

  

  vec3 L_ind = vec3(0.0);

  for(int i = 0; i < SAMPLE_NUM; i++){

    float pdf;

    vec3 localDir = SampleHemisphereCos(s, pdf);

    vec3 normal = GetGBufferNormalWorld(screenUV);

    vec3 b1, b2;

    LocalBasis(normal, b1, b2);

    vec3 dir = normalize(mat3(b1, b2, normal) * localDir);

  

    vec3 position_1;

    if(RayMarch(worldPos, dir, position_1)){

      vec2 hitScreenUV = GetScreenCoordinate(position_1);

      L_ind += EvalDiffuse(dir, wo, screenUV) / pdf * EvalDiffuse(wi, dir, hitScreenUV) * EvalDirectionalLight(hitScreenUV);

    }

  }

  

  L_ind /= float(SAMPLE_NUM);

  

  L = L + L_ind;

  

  vec3 color = pow(clamp(L, vec3(0.0), vec3(1.0)), vec3(1.0 / 2.2));

  gl_FragColor = vec4(vec3(color.rgb), 1.0);

  

}
```

### 预计算
IBL和PRT的本质是预计算，把离线计算积分的求解结果，在实时渲染阶段查表实现实时的效率

IBL预计算环境光辐照度
PRT(Precomputed Radiance Transfer)

球谐函数
引入：在环境光照下生成阴影,如果给了你环境光和一个diffuse的物体,在不考虑Shadow的情况下如何去计算shading值

Hammersley序列(低差异序列)
序列生成的仍然是随机样本，但样本分布更均匀
```cpp
Vec2f Hammersley(uint32_t i, uint32_t N) { // 0-1
    uint32_t bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    float rdi = float(bits) * 2.3283064365386963e-10;
    return {float(i) / float(N), rdi};
}
```
预计算的代价
	需要关注visibility常量，所以场景不能移动

## C++ 

extern"C"  
让编译器按照C语言编译作用域内的代码
哪些情况下使用extern "C"：
C++代码中调用C语言代码；
在C++中的头文件中使用；

### volatile、mutable和explicit
volatile:
**声明的类型变量表示可以被某些编译器未知的因素更改**，比如：操作系统、硬件或者其它线程使用 volatile 声明的变量的值的时候，**系统总是重新从它所在的内存读取数据**
两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，**该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中**，要求每次都从内存读取值而不是寄存器中读取值
mutable:在const函数中也可以修改的变量
```cpp
class person
{
    int m_A;
    mutable int m_B;//特殊变量 在常函数里值也可以被修改
public:
    void add() const//在函数里不可修改this指针指向的值 常量指针
    {
        m_A = 10;//错误  不可修改值，this已经被修饰为常量指针
        m_B = 20;//正确
    }
};
```

explicit:
explicit关键字用来修饰类的构造函数,被修饰的构造函数的类不能发生相应的隐式类型转换，只能以**显式的方式进行类型转换**

可以获取this指针到成员函数外操作吗  
this指针是一个右值，不能通过operator&获取地址  
调用成员函数时this指针自动设置并传递给函数

### static关键字
所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
默认初始化为0,存在全局未初始化区
全局static变量在程序启动时初始化
静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用。初始化的时机是在第一次调用这个函数进行
哪些函数不能是虚函数（构造，内联，静态，友元，类外普通）  

如何将const转为非const

```cpp

const_cast<T>

```

  

share_ptr<T>的循环引用  

两个share_ptr<T>相互指向导致无法析构对象  


裸指针构造两个shared_ptr会发生什么  

两次析构

  

智能指控制块  

std::unique_ptr:  

raw_ptr,deleter  

std::shared_ptr:  

raw_ptr,deleter,refcount;  

  

控制块在智能指针对象里吗  

指针在类内，但指向不同的堆区  

  

make_shared相比shared_ptr构造有什么好处

避免潜在内存泄漏

```cpp

processWidget(std::shared_ptr<Widget>(new Widget), //潜在的资源泄漏！

 computePriority());

```

如果std::shared_ptr<T>(T* t)失败，会导致资源泄漏。

make_shared 构造的智能指针会提供更强的异常安全性。如果在构造过程中发生异常，它会自动销毁已分配的资源和控制块，防止资源泄露。  

make_shared 预先分配了资源和控制块的内存,减少内存碎片

  

weak_ptr解引用  

不可以，std::weak_ptr<T>没有实现operator*  

  

静态成员函数和非静态成员函数的区别

静态成员函数地址唯一，所有类共用一份,非静态成员函数每个函数一份  

静态成员函数不能声明为虚函数，不能多态，但是可以重载  

非静态成员函数可以直接访问类的所有成员（包括私有成员），并且可以通过 this 指针来访问当前对象的成员。

静态成员函数只能直接访问类的静态成员（包括静态变量和静态函数），不能访问非静态成员。因为静态成员函数没有 this 指针，所以无法访问对象的非静态成员。

  

成员函数想返回一个指向自身shared_ptr怎么办  


```cpp
std::shared_ptr<MyClass> MyFunc() {

    return shared_from_this();

}
```


Undefined behavior  

```cpp

 int a[2]={0,1};a[-1];

```

能够通过编译，未定义行为的处理(异常，输出任意值等均由编译器决定)

  

一个Int64的数，如何求取该数二进制中1的个数，不用移位行不行？有没有更快的办法？打表的话占用内存太多了，怎么优化？  

1.打表  

2.Brian Kernighan 算法  

时间复杂度O(m),m为1的数量



```cpp
int countOnes(unsigned int n) {

    int count = 0;

  

    while (n != 0) {

        n = n & (n - 1);

        count++;

    }

  

    return count;

}
```



static_cast  

用于基本类型的转换、隐式转换和非多态类之间的转换  

编译时进行类型检查，只能用于已知类型之间的转换  

static_cast无法验证转换是否有效,无RTTI  

static_cast转换失败返回空指针/空引用  

dynamic_cast

用于多态类之间的转换  

RTTI(运行时类型检查)  

dynamic_cast可以判断转换是否成功，如果转换失败，则返回一个空指针（nullptr）（用于指针类型）或抛出一个std::bad_cast异常（用于引用类型）

dynamic_cast只能用于具有虚函数的类，通过比较对象的虚表来确定对象的实际类型  

  
  

**进程（Process）**：

  

进程是操作系统分配资源的基本单位，每个进程都有独立的地址空间和系统资源。

不同的进程之间相互独立，彼此之间不能直接共享内存和数据。

进程切换开销较大，需要进行上下文切换（寄存器状态、内存映射、打开文件等），因此切换速度慢。  

**线程（Thread）**：

  

线程是在进程内部执行的轻量级任务，与进程共享同一地址空间和系统资源。

线程之间可以共享内存和数据，通过共享实现线程间的通信和同步。

线程切换开销比进程小，因为线程在同一进程内，切换时只需保存和恢复少量的上下文信息。  

**协程（Coroutine）**：

  

协程是一种用户态的轻量级线程，由用户程序控制调度和切换。

协程之间可以有多个执行流，但只有一个执行上下文（内存和寄存器状态）。

协程可以主动挂起和恢复执行，不需要依赖操作系统的调度器。

协程切换开销非常小，因为切换时只需要保存和恢复协程栈的状态。  

  
  

trivial destructor  

当用户未定义类的析构函数时编译器生成的默认析构函数

  
  

RAII  

获取资源时初始化,析构时释放拥有的资源

  

浅拷贝原因

复制含堆内存时仅复制指针内容,指向了同一片堆内存区域　　

  

悬挂指针(dangling pointer)：指的是已经销毁的对象或已经回收的地址　　

  

**进程间通信的方法**  

信号量  

共享内存  

消息队列  

信号  

Socket  

RPC  

  

i++和++i

i++是先赋值再加，而++i是先加再赋值
  

### C++模板的展开过程
1. 实例化：编译器将模板中的泛型类型替换为具体类型，生成一个特定类型的模板。
2. 编译：编译器对生成的特定类型模板进行编译，检查代码的语法和语义，并生成相应的中间代码。
3. 链接：连接器将编译生成的代码链接到可执行文件中，生成最终的可执行文件。

### 堆和栈的区别

|  |堆|栈|
|---|---|---|
|**管理方式**|堆中资源由程序员控制（容易产生memory leak）|栈资源由编译器自动管理，无需手工控制|
|**内存管理机制**|系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）|只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）|
|**空间大小**|堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大|栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置）|
|**碎片问题**|对于堆，频繁的new/delete会造成大量碎片，使程序效率降低|对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）|
|**生长方向**|堆向上，向高地址方向增长。|栈向下，向低地址方向增长。|
|**分配方式**|堆都是动态分配（没有静态分配的堆）|栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。|
|**分配效率**|堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。|栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。|

### 为什么栈比堆块
操作系统会在底层对栈提供支持，会分配专门的寄存器(栈指针寄存器,x86 ESP)跟踪栈帧，栈的入栈出栈操作也比堆简单，有专门的指令
而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

### 内存对齐
成员按照声明顺序存储，第一个成员地址和整个结构体地址相同
未特殊说明时，按结构体中size最大的成员对齐
alignof可以计算出类型的对齐方式(C++11)
alignas可以指定结构体的对齐方式。(C++11)
好处
提高访问效率：内存对齐可以减少内存访问次数，提高访问效率
对于某些平台必须要求内存对齐(vulkan shader资源必须指定padding)
可以获取this指针到成员函数外操作吗  

this指针是一个右值，不能通过operator&获取地址  

调用成员函数时this指针自动设置并传递给函数

### 面向对象
继承
**让某种类型对象获得另一个类型对象的属性和方法。**
使用现有类的所有功能
实现继承：指使用基类的属性和方法而无需额外编码的能力
接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
封装
**把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。
多态
同一事物表现出不同事物的能力，**允许将子类类型的指针赋值给父类类型的指针**，
实现多态有二种方式：覆盖（override），重载（overload）。
覆盖：是指子类重新定义父类的虚函数的做法。
重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。

### 虚函数
哪些函数不能是虚函数（构造，内联，静态，友元，类外普通）  
虚函数表如何生成
对象被创建时，这个对象会拥有一个指向该类虚函数表的指针（vptr），这个指针指向类的虚函数表
虚函数表是和类还是对象绑定
虚函数表是和类绑定的，调用一个虚函数时，程序会通过对象的vptr找到该类对应的虚函数表，并根据函数在虚函数表中的位置调用正确的函数
纯虚函数
基类声明但无定义，每个子类都需要实现这个纯虚函数。目的是为了让派生类必须提供相应的实现，以满足特定的业务需求。
具有纯虚函数的基类不能实例化
重写（Override）
子类重写了父类的虚函数时，子类的虚函数表中会替换掉对应的虚函数地址，指向子类的实现

多继承
派生类包含每个基类的成员变量和成员函数
派生类的构造函数需要调用基类的构造函数以初始化基类对象。
派生类析构函数需要调用基类的析构函数以释放基类对象的资源。
如果有同名的成员函数或成员变量，则需要使用作用域解析运算符来区分不同的成员
多个基类继承了同一个基类，那么派生类中只包含单个该基类的实例，而不是多个复制

菱形继承
未指定虚继承时，派生类中包含多个相同的基类成员
使用虚继承后，共享的基类成员只会在派生类中存在一份
大小受虚表指针的大小和基类成员的大小，以及是否虚继承影响

final修饰的类，成员函数和虚函数不能被重写/继承
override标识派生类中的成员函数，表明该函数是对基类中虚函数的重写,override是对编译器的建议，要求明确的重写

基类不使用虚析构函数，会发生什么
会导致派生类中的成员无法得到释放造成内存泄漏

构造函数和析构函数能不能是虚函数，为什么
构造函数用于初始化对象的成员变量和执行必要的对象初始化工作，而在对象被构造时，派生类的成员还没有被完全创建，因此无法在构造函数中实现多态

类实例的内存存储形式
非静态成员变量
基类的子对象按照派生类中的声明顺序依次排列，最后是派生类自身的成员变量
虚函数表指针根据编译器实现位于首部或尾部

C++在构造函数和析构函数中的异常
构造函数中发生了异常，对象的析构函数将不会被调用，这可能导致资源泄漏


如何将const转为非const

```cpp

const_cast<T>


void modifyValue(const int& value) {
    int& nonConstValue = const_cast<int&>(value);
    nonConstValue = 10; // 修改非常量对象的值
}



int main()
{
     int a = 2;
    modifyValue(a);
    cout << a;//10
}

```
### 内存管理
  - 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
- 全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。
- 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。
- 代码区，存放程序的二进制代码- 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
- 全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。
- 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。
- 代码区，存放程序的二进制代码

### 智能指针
share_ptr<T>的循环引用  

两个share_ptr<T>相互指向导致无法析构对象  

引用计数如何保证不同类实例的指针之间共享同步
原子操作保证线程安全


裸指针构造两个shared_ptr会发生什么  
两次析构

  

智能指控制块  

std::unique_ptr:  

raw_ptr,deleter  

std::shared_ptr:  

raw_ptr,deleter,refcount;  

  

控制块在智能指针对象里吗  

指针在类内，但指向不同的堆区  

  

make_shared相比shared_ptr构造有什么好处

避免潜在内存泄漏

```cpp

processWidget(std::shared_ptr<Widget>(new Widget), //潜在的资源泄漏！

 computePriority());

```

如果std::shared_ptr<T>(T* t)失败，会导致资源泄漏。

make_shared 构造的智能指针会提供更强的异常安全性。如果在构造过程中发生异常，它会自动销毁已分配的资源和控制块，防止资源泄露。  

make_shared 预先分配了资源和控制块的内存,减少内存碎片

  

weak_ptr解引用  

不可以，std::weak_ptr<T>没有实现operator*  

  

静态成员函数和非静态成员函数的区别

静态成员函数地址唯一，所有类共用一份,非静态成员函数每个函数一份  

静态成员函数不能声明为虚函数，不能多态，但是可以重载  

非静态成员函数可以直接访问类的所有成员（包括私有成员），并且可以通过 this 指针来访问当前对象的成员。

静态成员函数只能直接访问类的静态成员（包括静态变量和静态函数），不能访问非静态成员。因为静态成员函数没有 this 指针，所以无法访问对象的非静态成员。

  

成员函数想返回一个指向自身shared_ptr怎么办  


```cpp
std::shared_ptr<MyClass> MyFunc() {

    return shared_from_this();

}
```


Undefined behavior  

```cpp

 int a[2]={0,1};a[-1];

```

能够通过编译，未定义行为的处理(异常，输出任意值等均由编译器决定)

类中静态变量的初始化是什么时候
类的定义外进行初始化

```cpp
class MyClass {
public:
    static int myStaticVariable; // 静态数据成员声明
};

int MyClass::myStaticVariable = 10; // 静态数据成员初始化
```

静态成员函数来初始化
```cpp
class MyClass {
public:
    static int getInitializedValue() {
        // 进行动态初始化的逻辑
        return 20;
    }
    static int myStaticVariable; // 声明静态数据成员
};

int MyClass::myStaticVariable = MyClass::getInitializedValue(); // 通过静态成员函数进行初始化
```
一个Int64的数，如何求取该数二进制中1的个数，不用移位行不行？有没有更快的办法？打表的话占用内存太多了，怎么优化？  

1.打表  

2.Brian Kernighan 算法  

时间复杂度O(m),m为1的数量


```cpp
int countOnes(unsigned int n) {

    int count = 0;

    while (n != 0) {

        n = n & (n - 1);

        count++;

    }
    return count;

}
```
##＃ 常量指针和指针常量

```cpp
int value = 5;
const int* ptr = &value;  // 常量指针，指向一个常量 int
*ptr = 10;  // 错误，不能通过常量指针修改所指向的值
ptr = nullptr;  // 可以修改指针本身，指向其他对象
```
```cpp
int value = 5;
int* const ptr = &value;  // 指针常量，指向一个可修改的 int
*ptr = 10;  // 可以通过指针常量修改所指向的值
ptr = nullptr;  // 错误，不能修改指针本身指向的对象
```
野指针
没有被初始化过的指针
悬空指针
指针最初指向的内存已经被释放,但未被置为nullptr
###  静态成员与普通成员的区别
静态成员变量从类被加载开始到类被卸载，一直存在；
普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束
静态成员变量是全类共享；普通成员变量是每个对象单独享用的
普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区
普通成员变量在构造函数初始化；静态成员变量在类外初始化
可以使用静态成员变量作为默认实参

static_cast  

用于基本类型的转换、隐式转换和非多态类之间的转换  

编译时进行类型检查，只能用于已知类型之间的转换  

static_cast无法验证转换是否有效,无RTTI  

static_cast转换失败返回空指针/空引用  

dynamic_cast

用于多态类之间的转换  

RTTI(运行时类型检查)  

dynamic_cast可以判断转换是否成功，如果转换失败，则返回一个空指针（nullptr）（用于指针类型）或抛出一个std::bad_cast异常（用于引用类型）

dynamic_cast只能用于具有虚函数的类，通过比较对象的虚表来确定对象的实际类型  


左值
可以取地址的变量,具名变量
右值
临时变量，立即数，不可取地址

右值引用
右值引用是一种新的引用类型，通过&&符号表示，用于引用将要被移动或者被临时创建的对象
实现移动语义和完美转发

std::move(T& t)
将T& t转换为T&& t，等价static_cast<T&&>(t)
  
移动语义
在对象被移动（例如函数返回值）时，避免不必要的对象拷贝和内存分配
移动构造

```cpp
class MyString {
public:
    MyString(MyString&& other) { // 实现移动构造函数
        data_ = other.data_;
        size_ = other.size_;
        other.data_ = nullptr;
        other.size_ = 0;
    }
private:
    char* data_;
    int size_;
};
```
完美转发
std::forward(T&&)
将参数转发给其他函数时，保留参数的值和类型信息，避免不必要的类型转换或信息损失

引用折叠
左值引用和右值引用进行嵌套时，编译器会自动将它们折叠成一个引用
```cpp
int x = 10;
int& & rref = x; // 折叠为 int&
```
```cpp
int&& && rref = std::move(x); // 折叠为 int&&
```
 ```cpp
int& && rref = x; // 折叠为 int&
```
内存泄漏排查
Valgrind
CRT 重载operator new
AddressSanitizer

trivial destructor  

当用户未定义类的析构函数时编译器生成的默认析构函数

std::vector<T>
动态数组，可以自动扩容
扩容策略 MSVC1.5倍扩容
定义移动构造时将原有元素移动到新内存区域，否则拷贝

STL对原始数组的好处
operator[]有合法性检测，防止下标越界等UB

怎么实现多态
使用虚函数和指针


虚函数可以内联吗 
虚函数可以被内联，但是只有在特定情况下才能内联。如果在调用虚函数的地方已经确定了需要调用的函数版本，那么编译器可以内联虚函数。

虚函数开销
查表，间接寻址

RAII  

获取资源时初始化,析构时释放拥有的资源

  

浅拷贝原因

复制含堆内存时仅复制指针内容,指向了同一片堆内存区域　　

  

悬挂指针(dangling pointer)：指的是已经销毁的对象或已经回收的地址　　

指针和引用的区别
指针可空，引用不可空，定义时必须初始化
指针可变指向对象，引用不可变引用对象
指针可以有多级，引用只有一级
sizeof(T*)为指针大小，sizeof(T&)为引用所指向变量的大小
当把指针作为参数进行传递时，传递实参拷贝，修改拷贝的指向不影响原有指针，修改引用参数会改变原有变量


i++和++i

i++是先赋值再加，而++i是先加再赋值



### STL
std::map 
内部实现为红黑树的关联型容器
提供log(n)的插入，删除，查找
键类型需要实现比较运算符
用于字典，计数，索引

### 一致性哈希
**移除或者增加一个结点时，能够尽可能小的改变已存在key的映射关系**
一致性哈希将整个哈希值空间组**织成一个虚拟的圆环**，使用相同的hash算法将数据和结点都映射到图中的环形哈希空间中
![](http://oss.interviewguide.cn/img/202205212342491.png)

### CPP源码到可执行程序的过程
#### 预编译
删除所有的#define，展开所有的宏定义。
处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”
处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件
删除所有的注释
保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用
添加行号和文件标识用于调试
#### 编译
预编译之后生成的xxx.i或xxx.ii文件进行一系列流程
词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分 割成一系列的记号。
语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。
语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义。
优化：源代码级别的一个优化过程。
目标代码生成,根据机器系统平台生成对应的汇编代码
目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移 来替代乘法运算、删除多余的指令等
#### 汇编
将汇编代码转变成机器可以执行的指令,根据汇编指令和机器指令的对照表一一翻译产生目标文件
####  链接
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链 接

### 链接
#### 静态链接
函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快。
#### 动态链接
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形 成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副 本，而是这多个程序在执行时共享同一份副本；

更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运 行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损 失。


## 八股

### **进程间通信的方法**  

信号量  

共享内存  

消息队列  

信号  

Socket  

RPC  

管道

### 进程线程协程
**进程（Process）**：
进程是操作系统分配资源的基本单位，每个进程都有独立的地址空间和系统资源。
不同的进程之间相互独立，彼此之间不能直接共享内存和数据。
进程切换开销较大，需要进行上下文切换（寄存器状态、内存映射、打开文件等），因此切换速度慢。  

**线程（Thread）**：
线程是在进程内部执行的轻量级任务，与进程共享同一地址空间和系统资源。
线程之间可以共享内存和数据，通过共享实现线程间的通信和同步。
线程切换开销比进程小，因为线程在同一进程内，切换时只需保存和恢复少量的上下文信息。  

**协程（Coroutine)**：

  

协程是一种用户态的轻量级线程，由用户程序控制调度和切换。

协程之间可以有多个执行流，但只有一个执行上下文（内存和寄存器状态）。

协程可以主动挂起和恢复执行，不需要依赖操作系统的调度器。

协程切换开销非常小，因为切换时只需要保存和恢复协程栈的状态。  

什么时候该用多线程，什么时候该用多进程？
- 频繁修改：需要频繁创建和销毁的优先使用**多线程**
- 计算量：需要大量计算的优先使用**多线程** 因为需要消耗大量CPU资源且切换频繁，所以多线程好一点
- 相关性：任务间相关性比较强的用**多线程**，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。
- 多分布：可能要扩展到多机分布的用**多进程**，多核分布的用**多线程**。

### 原子操作
处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作
（1）使用总线锁保证原子性
（2）使用缓存锁保证原子性

### 内存分段 内存分页 内存碎片
分段式分配是按需分配，有外部碎片而无内部碎片
固定式分配是固定分配的方式，有内部碎片而不会有外部碎片

### 并发和并行

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。


### OSI
- 物理层：底层数据传输，如网线；网卡标准。
    
- 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。
    
- 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。
    
- 传输层：端到端传输数据的基本功能；如 TCP、UDP。
    
- 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。
    
- 表示层：数据格式标识，基本压缩加密功能。
    
- 应用层：各种应用软件，包括 Web 应用。
![](http://oss.interviewguide.cn/img/202205072300887.png)


### UDP
UDP 是一个简单的传输层协议。和 TCP 相比，UDP 有下面几个显著特性：
- UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次
- UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。
- UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。
- UDP 支持多播和广播。
![](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png)

### TCP
- TCP 提供一种**面向连接的、可靠的**字节流服务
- - **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- - **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
- TCP 使用校验和，确认和重传机制来保证可靠传输
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

**注意**：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

### TCP 连接
TCP 四元组可以唯一的确定一个连接，四元组包括如下：
![](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230436594.png)
- 源地址
- 源端口
- 目的地址
- 目的端口

### **TCP 和 UDP 区别：**

_1. 连接_

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

_2. 服务对象_

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

_3. 可靠性_

- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：[如何基于 UDP 协议实现可靠传输？(opens new window)](https://xiaolincoding.com/network/3_tcp/quic.html)

_4. 拥塞控制、流量控制_

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

_5. 首部开销_

- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的。
- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

_6. 传输方式_

- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

_7. 分片不同_

- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

**TCP 和 UDP 应用场景：**

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- `FTP` 文件传输；
- HTTP / HTTPS；

由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 `DNS` 、`SNMP` 等；
- 视频、音频等多媒体通信；
- 广播通信；

### 为什么是三次握手？不是两次、四次
阻止重复历史连接的初始化,**为了防止旧的重复连接初始化造成混乱**
![](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png)

同步双方初始序列号

不使用「两次握手」和「四次握手」的原因：

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

B+树/B树
B+树分为中间节点和叶子节点
B+树的数据存在叶子节点中，B+树的叶子节点组成双向链表
B+树非叶子节点存储关键字，在查询时定位元素
B+树层级比B树少，更加矮胖，存储相同数据量树高更小，比较次数更少
B+树和B树的查询，插入，删除都是O(logn)
B+树的每次查询都会到叶子结点，查询次数稳定，叶子节点数据形成有序链表，便于范围查询
B树数据可以保存在非叶子节点

### 系统调用
操作系统提供给用户程序或应用程序的一组接口，用于访问操作系统的功能和资源。通过系统调用，应用程序可以请求操作系统执行特定的操作，例如文件读写、进程创建与终止、网络通信等。系统调用通常以编程语言提供的特殊语法或函数调用的形式存在，例如在Linux中，使用C语言的`syscall`函数来进行系统调用

### 库函数调用
库函数是预先编译好的可执行代码，封装了常用的功能和算法，并由操作系统或第三方开发者提供。通过调用库函数，应用程序可以重复使用已经实现的功能，而无需重新编写这些功能的代码。库函数可以包含在操作系统中，也可以由独立的软件包提供

### 为什么用库函数，不用系统调用
系统调用是操作系统特点的功能，直接使用系统调用不利于跨平台适配，否则需要针对不同操作系统编写特定代码
库函数提供了对底层系统调用的抽象，使得应用程序的编写更加方便和安全，隐藏内部实现
库函数提供了一系列常见操作的实现，可以省去重复编写代码的时间和精力

### 可重入函数
可以被多个线程同时调用而不会产生竞态条件或数据冲突的函数
特点
线程安全
不依赖于全局变量
不修改静态数据
不使用不可重入函数

### elf文件格式
**可执行文件链接格式**，它是 Linux 操作系统中可执行文件的存储格式
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/Elf.png

### 内存分配方式
全局变量，静态变量在编译期分配内存
栈上分配：局部变量，离开作用域销毁
堆上分配：new/malloc，分配在堆区(自由存储区)，需要手动管理生命周期

### 内存分配错误
使用未分配的区域如声明一个指针变量未使用new分配便访问类型内的成员变量
分配成功但未初始化就使用
下标越界，下标越界是UB，具体行为由编译器决定
内存泄漏
重复释放内存
释放内存未置为nullptr出现野指针
返回一个函数内部局部变量的地址

### 虚拟内存
#### 设计目的
让物理内存扩充成更大的逻辑内存，让每一个程序拥有更多的逻辑内存运行
将内存抽象为地址空间，每一个程序进程有独立的地址空间，让应用程序之间进行隔离，避免直接使用物理地址发生访问冲突。
程序使用虚拟内存地址，需要映射到物理内存地址进行寻址操作

#### 地址映射使用内存分段/分页进行管理
分段式管理通过虚拟地址的段号和段内偏移映射到物理地址
分段的问题有外部内存碎片和内存交换的效率低的问题
#### 分段的特性
因为分段是要根据实际需求分配内存，所以不会有内部碎片，但多个段的分配会产生不连续的小内存碎片(自由可用内存),无法被其它程序使用的外部碎片
解决外部碎片可用用内存交换写入磁盘再写回，整理内存碎片，但是当段较大时，写入磁盘占用时间长会导致性能瓶颈

分页式把整个虚拟地址空间和物理内存空间按固定的页长度切分，通过页表实现物理地址和虚拟地址之间的映射关系。页表保存在内存中，MMU负责这个转换工作
![](https://cdn.xiaolincoding.com//mysql/other/08a8e315fedc4a858060db5cb4a654af.png)
当虚拟地址的页号在页表中查不到，就会产生缺页异常，由相关系统调用进入内核空间分配物理内存更新页表
#### 分页的特性
空间已经预先分配成了页，按页分配就不存在外部碎片的问题，但是数据很可能不能完全使用完一整页，会有内部碎片出现。
因为程序局部性，不需要一次性加载很多内存，可以把常用的页面保存在页框，把一些页面换出
当内存空间不够会把页面换出，当调用再换入
换入换出有多种策略(LRU/LFU/LRU-K/CLOCK replacer)

#### 映射策略
虚拟地址=页号-页内偏移，根据页表查询对应物理页的页号进行地址换算获得物理地址

- 把虚拟内存地址，切分成页号和偏移量；
- 根据页号，从页表里面，查询对应的物理页号；
- 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

#### 分页缺陷
每个程序都有自己的页表?一个页表项需要4kb存储，那么页表项占用是巨大的,4GB的页面映射就需要4MB的页表，不能每个程序都需要占用这么多

使用多级页表缓解
把页表项放进页面，在对这些页面进行一次映射
也就是一级页号和二级页号

### TLB
快表
cache的思路，通过硬件级的MMU芯片完成地址转换和TLB的访问交互


### 哈希表
哈希表是一种保存键值对（key-value）的数据结构。
key不重复，一个key对应一个value
O(1)时间根据key查询,修改，删除value，当无任何优化手段时，哈希冲突严重时最坏时间复杂度O(n) 

为什么能O(1)查询
key 通过 Hash 函数的计算，就能定位数据在表中的位置,哈希表是基于数组设计的数据结构，可以快速通过索引定位

哈希冲突
不同的key经过hash(key)计算结果相同导致冲突，映射到了同一位置

解决哈希冲突
开放地址法：当发生哈希冲突时，使用一定的方式从哈希表中的其他槽位中寻找下一个可用的空槽位进行插入。开放地址法的实现方法包括线性探测、二次探测和双重哈希等。

